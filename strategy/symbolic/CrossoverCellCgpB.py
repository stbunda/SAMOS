import copy

import numpy as np
from pymoo.core.crossover import Crossover
from pymoo.operators.repair.to_bound import set_to_bounds_if_outside_by_problem
from search_space.symbolic.CellCGPb import CellCgpb
from search_space.symbolic.GenCGPb import GenCgpb


class CrossoverCellCgpB(Crossover):
    """
    A custom crossover operator for Cell-based Cartesian Genetic Programming with weights (CellCgpW).
    This class implements a specialized crossover mechanism suitable for evolutionary algorithms.

    Attributes:
        eta (float): Parameter controlling the distribution index of the simulated binary crossover (SBX).
        n_offsprings (int): Number of offsprings generated by the crossover.
        prob_per_variable (float): Probability of crossover for each variable.
    """

    def __init__(self, eta=15, n_offsprings=2, prob_per_variable=0.5, **kwargs):
        """
        Initialize the crossover operator.

        Args:
            eta (float, optional): Distribution index for SBX. Defaults to 15.
            n_offsprings (int, optional): Number of offsprings. Defaults to 2.
            prob_per_variable (float, optional): Probability of crossover per variable. Defaults to 0.5.
            **kwargs: Additional arguments passed to the parent class.
        """
        super().__init__(2, n_offsprings, **kwargs)
        self.eta = float(eta)
        self.prob_per_variable = prob_per_variable

    def crossover_base(self, X, problem, index):
        """
        Perform the base crossover operation on the given population.

        Args:
            X (ndarray): Population to apply crossover, with shape
                         (temporal_dimensions, number_of_matings, variables).
            problem (Problem): Problem definition, providing variable bounds.
            index (int): Index of the Normal block to perform crossover on.

        Returns:
            ndarray: New population after applying crossover.
        """
        # Initialize variables and convert individuals to real representation
        tem, n_matings, n_var = X.shape
        X_copy = copy.deepcopy(X)
        X_t = np.zeros(shape=(tem, n_matings, X[0, 0, 0].n_var_size))

        # Flatten and prepare genetic data for crossover
        for i in range(tem):
            for j in range(n_matings):
                X[i, j, 0].individual[index].toReal()
                X_t[i, j, :] = X[i, j, 0].individual[index].realgene.flatten()
        X = X_t.astype(float)
        tem, n_matings, n_var = X.shape

        # Problem boundaries
        xl, xu = problem.xl, problem.xu

        # Create a crossover mask
        do_crossover = np.full(X[0].shape, True)
        do_crossover[np.random.random((n_matings, n_var)) > self.prob_per_variable] = False
        do_crossover[np.abs(X[0] - X[1]) <= 1.0e-14] = False

        # Determine smaller and larger values
        y1 = np.min(X, axis=0)
        y2 = np.max(X, axis=0)

        # Generate random values for SBX
        rand = np.random.random((n_matings, n_var))

        def calc_betaq(beta):
            """
            Calculate the beta distribution used in SBX.

            Args:
                beta (ndarray): Current beta values for crossover.

            Returns:
                ndarray: Adjusted beta values for offspring generation.
            """
            alpha = 2.0 - np.power(beta, -(self.eta + 1.0))
            mask, mask_not = (rand <= (1.0 / alpha)), (rand > (1.0 / alpha))
            betaq = np.zeros(mask.shape)
            betaq[mask] = np.power((rand * alpha), (1.0 / (self.eta + 1.0)))[mask]
            betaq[mask_not] = np.power((1.0 / (2.0 - rand * alpha)), (1.0 / (self.eta + 1.0)))[mask_not]
            return betaq

        # Calculate offspring genetic data
        delta = y2 - y1
        delta[delta < 1.0e-10] = 1.0e-10  # Avoid division by zero

        beta = 1.0 + (2.0 * (y1 - xl) / delta)
        c1 = 0.5 * ((y1 + y2) - calc_betaq(beta) * delta)

        beta = 1.0 + (2.0 * (xu - y2) / delta)
        c2 = 0.5 * ((y1 + y2) + calc_betaq(beta) * delta)

        # Randomly swap variables between offspring
        b = np.random.random((n_matings, n_var)) <= 0.5
        c1[b], c2[b] = c2[b], c1[b]

        # Assign crossover results to new individuals
        c = np.copy(X)
        c[0, do_crossover] = c1[do_crossover]
        c[1, do_crossover] = c2[do_crossover]

        c[0] = set_to_bounds_if_outside_by_problem(problem, c[0])
        c[1] = set_to_bounds_if_outside_by_problem(problem, c[1])

        # Reconstruct individuals with updated genetic data
        X_ori = np.full(X_copy.shape, None)
        shapeX = X_copy[0, 0, 0].individual[index].realgene.shape

        for k in range(tem):
            for p in range(n_matings):
                X_ori[k, p, 0] = copy.deepcopy(X_copy[k, p, 0])
                X_ori[k, p, 0].individual[index] = GenCgpb(
                    X_copy[k, p, 0].conf_net[index],
                    np.copy(c[k, p].reshape(shapeX)),
                    weights=X_copy[k, p, 0].individual[index].weightcolums
                )
                X_ori[k, p, 0].individual[index].to_int_cgp()

        return X_ori

    def _do(self, problem, X, **kwargs):
        """
        Execute the crossover operation on the given population.

        Args:
            problem (Problem): Problem definition, providing variable bounds.
            X (ndarray): Population to apply crossover.

        Returns:
            ndarray: Updated population after crossover.
        """
        X_temp = copy.deepcopy(X)

        for i in range(X[0, 0, 0].normal):
            X_temp = self.crossover_base(X_temp, problem, i)

        return X_temp
